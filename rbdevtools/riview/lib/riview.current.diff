diff --git a/gemreg/lib/riview.rb b/gemreg/lib/riview.rb
index d54e90e..452f575 100644
--- a/gemreg/lib/riview.rb
+++ b/gemreg/lib/riview.rb
@@ -3,6 +3,27 @@
 ## test:
 ##  app = RIViewApp.new; app.run_threaded
 
+## FIXME before porting to gir_ffi-gtk3, the latter would need
+## to be extended for at least ...
+##
+## - define GtkWidgetClass
+##   - define GtkWidget/GtkWidgetClass bind_template_child_full ...
+##     ... as a class method, locally, via some "interface module"
+## - see TemplateBuilder, ...
+##
+## - define GtkBuildable (already defined)
+##   - define gtk_buildable_get_internal_child - see TemplateBuilder
+##   - define initially via a Gtk::Buildable as a module, and extend
+##
+## - define Gio::Resource - see ResourceTemplateBuilder
+##
+## - TBD interfaces (in C) via GIR ??? & how git_ffi works
+##   NB @ basedir ~/.local/share/gem/ruby/3.0.0/gems/gir_ffi-0.15.9/lib/gir_ffi/
+##   - builders/type_builder.rb
+##     NB GirFFI::Builders::TypeBuilder::TYPE_MAP.keys
+##   - builders/interface_builder.rb#
+##   - builders/registered_type_builder.rb
+
 require 'gtk3'
 
 require('logger')
@@ -292,8 +313,6 @@ module LogModule
 end
 
 
-
-
 require_relative('storetool.rb')
 require_relative('spectool.rb')
 
@@ -478,11 +497,63 @@ module TemplateBuilder
 
   end
 
-  ## NB this defines an instance method ui_internal in the including class
   def ui_internal(id)
+    ## NB this definition provides an instance method ui_internal
+    ## in the including class
+    ##
+    ## Notes - type inheritance with mixin modules used via include
+    ## or extend, in Ruby
+    ##
+    ## - 'include' affects the type of instances of the including class
+    ## - 'extend' affects the type of the including class
+    ##
+    ## Given:
+    ##
+    ##   app = RIViewApp.new; app.run_threaded
+    ##   rw = RIViewWindow.new(app)
+    ##
+    ##   rw.is_a?(TemplateBuilder) => true
+    ##
+    ##   rw.class.is_a?(FileTemplateBuilder) => true
+    ##
+    ##   rw.is_a?(UIBuilder) => false
+    ##   rw.class.is_a?(UIBuilder) => true
+    ##
+    ## Usage notes:
+    ## - 'extend' modules can define instance methods in the including
+    ##    class, using define_method with a locally defined proc,
+    ##    generally outside of the 'self.extended' section of the module
+    ##
+    ##    - that proc can be provided as a lambda proc if initialized
+    ##      for storage in a variable e.g block = lambda {...}, then
+    ##      provided to define_method as e.g &block
+    ##    - or it can be defined as a block that does not check
+    ##      arguments and does not have the return semantics of a lambda
+    ##      proc
+    ##
+    ## - 'include' modules can define instance methods in the including
+    ##    class, using 'def'
+    ##
+    ## - 'extend' may generally be useful for mixin modules to add class
+    ##   methods to a class. It can be used to add instance modules to a
+    ##   class, using such as the define_method approach denoted above
+    ##
+    ## - 'include' may generally be useful for mixin modules to add
+    ##   instance  methods to a class. It may also be used to add class
+    ##   methods, in the 'self.included' section of the include module
+    ##
+    ## - Considering that 'include' supports both class method and
+    ##   instance method definition with 'def' in the defining module --
+    ##   as whether in the mixin module's self.included section e.g 'def
+    ##   extclass.method_name' or respectively, not in the self.included
+    ##   section - 'include' may appear to be more generally useful for
+    ##   applications. Regardless, considering how 'extend' affects the
+    ##   type of a class - notwithstanding the type of the instances of
+    ##   the class - this feature in itself may bear some consideration,
+    ##   towards applications of 'extend' with modules
+    ##
     self.get_internal_child(self.class.builder, id)
   end
-
 end
 
 
@@ -538,7 +609,7 @@ module ResourceTemplateBuilder
     ## valid resource path onto the resource bundle initialized to this
     ## class
     ##
-    ## This method is used by GTK
+    ## This method is used by Gtk support in Ruby-GNOME
     ##
     ## @see ::use_resource_bundle
     ## @see ::use_template
@@ -566,7 +637,7 @@ module FileTemplateBuilder
 
     ## load this class' template as a file
     ##
-    ## This method is used by GTK
+    ## This method is used by Gtk support in Ruby-GNOME
     ##
     ## @see ::use_template
     def extclass.init
@@ -657,6 +728,8 @@ class RIViewWindow < Gtk::ApplicationWindow
 
     @logger = application.logger
 
+    ## NB init_template will be called under Gtk::Widget#initialize_post
+
     set_window_action("new") {
       @logger.debug("Action 'new' in #{self} (#{Thread.current})")
       application.map_app_window_new
@@ -679,7 +752,7 @@ class RIViewWindow < Gtk::ApplicationWindow
     }
 
     self.signal_connect("destroy") {
-      @logger.debug("Signal 'destory' in #{self} (#{Thread.current})")
+      @logger.debug("Signal 'destroy' in #{self} (#{Thread.current})")
       closeAct.activate
     }
 
@@ -705,9 +778,11 @@ class RIViewWindow < Gtk::ApplicationWindow
     ## hash table with same keys as in gem_stores
 
     ## FIXME though it's not the most succinct thing still, this should
-    ## be reading for testing with iteration onto the site store -
+    ## be ready for testing with iteration onto the site store -
     ## modules, classes, methods
 
+    ## NB using the initial store.append(nil) iterator for the first
+    ## root tree model entry, as a branch
     builder.add_branch(true, "System", "Store", nil, sysproxy)
     itersys = store.append(builder.iterator)
     ## NB RI has Abbrev.abbrev documented as both a class method and an
@@ -718,9 +793,9 @@ class RIViewWindow < Gtk::ApplicationWindow
     ##
     builder.add_branch(true, "Abbrev", "Module", "Abbrev", sysproxy,
                        iterator: itersys)
-    builder.add_leaf(true, "abbrev", "Class Method", "Abbrev::abbrev", sysproxy, 
+    builder.add_leaf(true, "abbrev", "Class Method", "Abbrev::abbrev", sysproxy,
                      iterator: itersys)
-    builder.add_leaf(true, "abbrev", "Instance Method", "Abbrev#abbrev", sysproxy, 
+    builder.add_leaf(true, "abbrev", "Instance Method", "Abbrev#abbrev", sysproxy,
                      iterator: itersys)
 
     builder.add_leaf(true, "A", "B", "A", sysproxy)
@@ -753,8 +828,11 @@ class RIViewWindow < Gtk::ApplicationWindow
     builder.add_leaf(true, "B", "Test", iterator: itergems)
 
 
+    ## FIXME remove the 'exp' column from the tree store/model
+    ##
+    ## GTK handles the "folded state" internal to the UI,
+    ## independent of the data model
 
-    ## FIXME the following do not show up
     @topic_store = store
 
     @pageview = ui_internal("RIPageView")
@@ -785,6 +863,8 @@ class RIViewWindow < Gtk::ApplicationWindow
 end
 
 
+require_relative 'sysexits'
+
 class RIDocView < Gtk::TextView
   extend FileTemplateBuilder
   ## FIXME only one template-based class per UI file...?
@@ -1007,8 +1087,9 @@ class GBuilderApp < Gtk::Application
     # }
   end
 
-  def run()
+  def run()  ## FIXME move to GApp
     @logger.debug("#{__method__} in #{Thread.current}")
+
     begin
       self.register()
     rescue Gio::IOError::Exists
@@ -1018,9 +1099,16 @@ class GBuilderApp < Gtk::Application
       ##   G_APPLICATION_NON_UNIQUE, however that may be represented
       ##   in the Ruby API. If it was defined as such, TBD side effects
       @logger.fatal("Unable to register #{self}")
+    ## NB DNW: calling Gtk.main after A) the app is closed, B) Gtk.main_quit
+    ##
+    ## FIXME define a service implementation of this app,
+    ## such that can be used from IRB
     else
       ## TBD storing main_thread - see also the GMain loop API via Ruby ...
       @main_thread = Thread.current
+      ## FIXME bind to an 'initialized' signal, with a proc
+      ## that will @syncMtx.synchronize { @syncCv.signal }
+
       ## super(gtk_cmdline_args) # TBD
       @logger.debug("#{__method__} calling Gtk.main in #{Thread.current}")
       # @state = :run
@@ -1038,22 +1126,22 @@ class GBuilderApp < Gtk::Application
             ## ... such that would fail recursively, if the only warning
             ## handler would be trying to dispatch to a logger
             warn "Received SIGTRAP. Exiting in #{Thread.current.inspect}"
-            #Gtk.main_quit
-            exit(false)
+            Gtk.main_quit
+            exit(SysExit::EX_SOFTWARE)
           }
         end
         Signal.trap("INT") do
           LogModule.with_system_warn {
             warn "Received SIGINT. Exiting in #{Thread.current.inspect}"
-            #Gtk.main_quit
-            exit(false)
+            Gtk.main_quit
+            exit(SysExit::EX_IOERR)
           }
         end
         Signal.trap("ABRT") do
           LogModule.with_system_warn {
             warn "Received SIGABRT. Exiting in #{Thread.current.inspect}"
-            #Gtk.main_quit
-            exit(false)
+            Gtk.main_quit
+            exit(SysExit::EX_PROTOCOL)
           }
         end
 
@@ -1068,22 +1156,43 @@ class GBuilderApp < Gtk::Application
         ## This TracePoint is not reached for the peculiar
         ## NoMethodError denoted below - that might be emitted from C
         trace = TracePoint.new(:raise) do |pt|
-          ## FIXME if using this with a Ruby console, provide a way
-          ## to filter 'pt' as to ignore a 'pt' with any of the
- ## following qualities:
-          ## - pt.raised_exxception class matching some class or module
-          ##   name, as itself or in c.ancestors
-          ##   - e.g ignore onto Doc::Store::MissingFileError,
-          ##     RubyLex::TerminateLineInput, ...
-          ## - pat.path matching some value
-          ##   - e.g ignore onto pt.path.match(/lib/rdoc/store.rb/)
-          warn("[debug] %s %s [%s] @ %s:%s " %
-               [pt.event, pt.raised_exception.inspect,
-                pt.raised_exception.message,
-                pt.path, pt.lineno])
+          pt_exc = pt.raised_exception
+          pt_path = pt.path
+          ## exceptions to ignore
+          ign_exc = [RDoc::Store::MissingFileError,
+                     RubyLex::TerminateLineInput,
+                     SyntaxError]
+          unless (ign_exc.member?(pt_exc.class))
+            puts("[debug] %s %s [%s] @ %s:%s" %
+                 [pt.event, pt_exc.class,
+                  pt_exc.message,
+                  pt_path, pt.lineno])
+          end
         end
         trace.enable
 
+
+        ## FIXME in review of the previous, it may be more effective
+        ## to define a tracepoint on 'warn' than to shadow the 'warn' method
+        ## to direct any warning output to a logger - assuming that this
+        ## will not in itself result in a warning in Ruby (e.g when
+        ## logging during a signal trap handler)
+        ##
+        ## as such, an extension could be defined on TracePoint that
+        ## would provide a mutex for locking the instance's "enabled'
+        ## field. That mutex could be held and the instance disabled,
+        ## e.g within any signal trap handler - such that the mutex-
+        ## sync'd form would return the 'enabled' state of the
+        ## TracePoint to its original value, via a final 'ensure' form
+        ##
+        ## FIXME this app needs a log viewer
+
+        ## FIXME this app needs a trace support module
+        ## => popup for tracepoint inspection (bindings, etc)
+        ## ... may be tricky to implement e.g for any tracepoint on 'raise'
+        ##
+        ## see ./tracetest.rb, ./tracetool.rb
+
         Gtk.main()  ## FIXME move to GtkApp < GApp :: #main(args = nil)
         ## vis a vis args, note e.g '--gapplication-app-id' in GLib's GApplication
         ## and other args avl with GtkApplication
@@ -1093,6 +1202,12 @@ class GBuilderApp < Gtk::Application
         ## NB GRubyService < GConsoleService < GApp
         ## TBD GShellService < GConsoleService
 
+        ## NB example of Glib::MainLoop application
+        ## ~/.local/share/gem/ruby/3.0.0/gems/vte3-3.4.9/test/test-terminal.rb
+        ## see also: "The Main Event Loop" in the GLib devhelp manual
+
+        #@main = GLib::MainLoop.new
+
 
         ## FIXME in this source file, store every return value from
         ## signal_connect within an array of signal callback IDs.
@@ -1226,6 +1341,9 @@ class RIViewApp < GBuilderApp
   end
 
   def map_prefs_window()
+    #raise "Error test"
+    ## ^ uncaught from within Gtk.main, despite every effort otherwise
+    ##   => app exits (FIXME)
     unless @prefs_window ## FIXME unset when destroyed
       w =  RIViewPrefsWindow.new(self)
       @logger.debug("Using new prefs window #{w}")
@@ -1279,6 +1397,74 @@ gtk_widget_destroyed ??
 
 =end
 
+=begin TBD
+
+also problematic
+
+irb(main):075:0> GLib::Log.log("Frob",GLib::Log::LEVEL_ERROR,"frob")
+
+(irb:33315): Frob-ERROR **: 13:17:37.431: frob
+
+Trace/breakpoint trap (core dumped)
+
+-----
+
+similarly problematic
+
+irb(main):001:0> require 'gtk3'
+=> true
+irb(main):002:0> GLib::Log.always_fatal=0
+=> 0
+irb(main):003:0> GLib::Log.log("Frob",GLib::Log::LEVEL_ERROR,"Frob")
+
+(process:36589): Frob-ERROR **: 13:21:32.340: Frob
+Trace/breakpoint trap (core dumped)
+
+----
+similarly
+
+irb(main):001:0> require 'gtk3'; DM="Frob"
+=> true
+irb(main):002:0> GLib::Log::set_fatal_mask(DM,0)
+=> 5G
+irb(main):003:0> GLib::Log.log(DM,GLib::Log::LEVEL_ERROR,"Frob")
+
+(process:36765): Frob-ERROR **: 14:08:01.120: Frob
+Trace/breakpoint trap (core dumped)
+
+-----
+albeit, from the devehlp for g_log calls: "G_LOG_LEVEL_ERROR is always fatal"
+
+So, ...
+
+irb(main):003:0> GLib::Log::set_fatal_mask(DM,GLib::Log::LEVEL_CRITICAL)
+=> 5
+irb(main):004:0> GLib::Log.log(DM,GLib::Log::LEVEL_CRITICAL,"Frob")
+
+(process:36797): Frob-CRITICAL **: 14:12:03.362: Frob
+Trace/breakpoint trap (core dumped)
+
+... is that really how it's supposed to exit now?
+
+TBD: Produce a list of log domains used through the Ruby GTK code, at
+some known release - and how to reference those as constants
+
+----
+
+TBD: Patching the src to provide support for log handling w/ GTK in Ruby
+
+... it doesn't provide any way to map a function into the log
+handling. This only sets a log level mask:
+
+      GLib::Log.set_handler(domain, mask)
+
+... looking at
+~/.local/share/gem/ruby/3.0.0/gems/glib2-3.4.9/lib/glib2.rb
+
+and at g_log_set_writer_func() in devhelp => call exactly once in each GTK app process
+
+=end
+
 ## Local Variables:
 ## fill-column: 65
 # End:
